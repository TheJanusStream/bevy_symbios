use bevy::prelude::*;
use bevy_symbios::LSystemMeshBuilder;
use symbios_turtle_3d::{Skeleton, SkeletonPoint};

// Helper for testing
fn build_skeleton_from_points(points: Vec<Vec3>) -> Skeleton {
    let mut s = Skeleton::new();
    for (i, p) in points.iter().enumerate() {
        s.add_node(
            SkeletonPoint {
                position: *p,
                rotation: Quat::IDENTITY,
                radius: 0.1,
                color: Vec4::ONE,
                material_id: 0,
                uv_scale: 1.0,
            },
            i == 0, // New strand on first point
        );
    }
    s
}

#[test]
fn test_singularity_robustness() {
    // A 180-degree turn: Up then Down.
    let points = vec![
        Vec3::ZERO,
        Vec3::Y,
        Vec3::ZERO, // Fold back
    ];
    let s = build_skeleton_from_points(points);

    let builder = LSystemMeshBuilder::default();
    let meshes = builder.build(&s);
    let mesh = meshes.get(&0).expect("Mesh 0 not generated");

    // Check vertex count.
    // 3 points = 2 segments with same material.
    // With vertex sharing, the middle ring is reused: 3 rings * 9 verts = 27 vertices.
    let positions = mesh
        .attribute(Mesh::ATTRIBUTE_POSITION)
        .unwrap()
        .as_float3()
        .unwrap();
    assert_eq!(positions.len(), 27, "Singularity caused vertex dropout");

    // Check for "Pinching".
    // Ring 1 (Index 9..18) corresponds to the top of the first segment (at Y).
    // It should maintain radius distance from the central axis.
    let mid_ring_start = 9;
    for i in 0..9 {
        let pos = Vec3::from_array(positions[mid_ring_start + i]);
        // Distance from Y-axis should be ~0.1 (radius)
        let dist = Vec2::new(pos.x, pos.z).length();
        assert!(
            (dist - 0.1).abs() < 0.01,
            "Tube collapsed at singularity (radius: {})",
            dist
        );
    }
}

#[test]
fn test_colinear_point_filtering() {
    // Points at same location should be filtered or handled gracefully.
    let points = vec![
        Vec3::ZERO,
        Vec3::ZERO, // Duplicate!
        Vec3::Y,
    ];
    let s = build_skeleton_from_points(points);

    let builder = LSystemMeshBuilder::default();
    let meshes = builder.build(&s);
    let mesh = meshes.get(&0).expect("Mesh 0 not generated");

    let positions = mesh
        .attribute(Mesh::ATTRIBUTE_POSITION)
        .unwrap()
        .as_float3()
        .unwrap();

    // We accept either filtering (18 verts) or robust handling.
    for pos in positions {
        assert!(
            Vec3::from_array(*pos).is_finite(),
            "NaN generated by colinear points"
        );
    }
}
