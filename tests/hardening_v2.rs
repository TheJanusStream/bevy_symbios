use bevy::prelude::*;
use bevy_symbios::LSystemMeshBuilder;
use symbios_turtle_3d::{Skeleton, SkeletonPoint};

// Helper for testing
fn build_skeleton_from_points(points: Vec<Vec3>) -> Skeleton {
    let mut s = Skeleton::new();
    for (i, p) in points.iter().enumerate() {
        s.add_node(
            SkeletonPoint {
                position: *p,
                rotation: Quat::IDENTITY,
                radius: 0.1,
            },
            i == 0, // New strand on first point
        );
    }
    s
}

#[test]
fn test_singularity_robustness() {
    // A 180-degree turn: Up then Down.
    // If the Parallel Transport frame fails here, the tube often collapses to 0 volume or twists 90 degrees.
    let points = vec![
        Vec3::ZERO,
        Vec3::Y,
        Vec3::ZERO, // Fold back
    ];
    let s = build_skeleton_from_points(points);

    let builder = LSystemMeshBuilder::default();
    let mesh = builder.build(&s);

    // Check vertex count.
    // 3 points = 3 rings. 8 resolution (default) = 9 verts per ring.
    // Total = 27 vertices.
    let positions = mesh
        .attribute(Mesh::ATTRIBUTE_POSITION)
        .unwrap()
        .as_float3()
        .unwrap();
    assert_eq!(positions.len(), 27, "Singularity caused vertex dropout");

    // Check for "Pinching".
    // At the fold (index 1), the vertices should still be at radius distance from the center line.
    // If the frame collapsed, they might be at (0, y, 0).
    let mid_ring_start = 9;
    for i in 0..9 {
        let pos = Vec3::from_array(positions[mid_ring_start + i]);
        // Distance from Y-axis should be ~0.1 (radius)
        let dist = Vec2::new(pos.x, pos.z).length();
        assert!(
            (dist - 0.1).abs() < 0.01,
            "Tube collapsed at singularity (radius: {})",
            dist
        );
    }
}

#[test]
fn test_colinear_point_filtering() {
    // Points at same location should be filtered or handled gracefully.
    let points = vec![
        Vec3::ZERO,
        Vec3::ZERO, // Duplicate!
        Vec3::Y,
    ];
    let s = build_skeleton_from_points(points);

    let builder = LSystemMeshBuilder::default();
    let mesh = builder.build(&s);

    // If logic works, it should treat this as a single segment from 0 to Y.
    // 2 rings = 18 vertices.
    // If it fails (treats 0->0 as valid), it might try to make 3 rings or NaN.
    let positions = mesh
        .attribute(Mesh::ATTRIBUTE_POSITION)
        .unwrap()
        .as_float3()
        .unwrap();

    // We accept either filtering (18 verts) or robust handling (27 verts).
    // The key is that positions are finite.
    for pos in positions {
        assert!(
            Vec3::from_array(*pos).is_finite(),
            "NaN generated by colinear points"
        );
    }
}
